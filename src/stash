
    #[test]
    fn discrete_fourier_fft() {
        let v = vec![
            Complex::from(1_f64), Complex::from(2_f64) - Complex::i(), -Complex::i(), Complex::from(-1_f64) + 2_f64 * Complex::i()
        ];
        assert_eq!(fft_subroutines::fast_fourier(v), vec![
            Complex::from(2_f64), -Complex::from(2_f64) - Complex::i(), -2_f64 * Complex::i(), Complex::from(4_f64) + 4_f64 * Complex::i()
        ]);
        let w = vec![
            Complex::from(0_f64), Complex::from(1_f64), Complex::from(0_f64), Complex::from(0_f64)
        ];
        assert_eq!(fft_subroutines::fast_fourier(w), vec![
            Complex::from(2_f64), -Complex::from(2_f64) - Complex::i(), -2_f64 * Complex::i(), Complex::from(4_f64) + 4_f64 * Complex::i()
        ]);
    }

    #[test]
    fn unity_roots_fft () {
        assert_eq!(
            fft_subroutines::unity_roots(&[0, 1, 2, 3, 4], 1)
                .into_iter()
                .map( |k| ( (k.re as f32).round_to(1000_f32), (k.im as f32).round_to(10000_f32) ))
                .collect::<Vec<_>>(),
            vec![
                Complex::from(1_f32), 
                Complex::new(0.3090_f32, 0.9511_f32),
                Complex::new(-0.8090_f32, 0.5878_f32), 
                Complex::new(-0.8090_f32, -0.5878_f32),
                Complex::new(0.3090_f32, -0.9511_f32)
            ].into_iter()
                .map(|k| (k.re, k.im))
                .collect::<Vec<_>>()
        );
    }